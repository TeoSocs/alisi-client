/*
 * ALISI client
 *
 * This is the client API of ALISI. Each device will expose this API in order to be identified by ALISI compliant control units.
 *
 * API version: 1.0.0
 * Contact: matteo.sovilla@studenti.unipd.it
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"encoding/base64"
	"encoding/json"
	"errors"
	"github.com/TeoSocs/alisi-client/crypto"
	"github.com/TeoSocs/alisi-client/datamodel"
	"github.com/gorilla/mux"
	"io/ioutil"
	"net/http"
)

const TEST_API_KEY = "testAPIkey"

func checkAuth(w http.ResponseWriter, r *http.Request) (err error) {
	if r.Header.Get("X-API-Key") != TEST_API_KEY {
		http.Error(w, "API key is missing or invalid", http.StatusUnauthorized)
		w.Header().Add("WWW-Authenticate", `Basic realm="Access to the ALISI device"`)
		err = errors.New("API key is missing or invalid")
	}
	return
}

func CreateClaim(w http.ResponseWriter, r *http.Request) {
	if err := checkAuth(w, r); err != nil {
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		log.Errorf("error reading body: %v", err)
		http.Error(w, "can't read body", http.StatusBadRequest)
		return
	}

	var encodedClaim datamodel.EncodedClaim
	err = json.Unmarshal(body, &encodedClaim)

	if err != nil {
		log.Errorf("error reading encodedClaim: %v", err)
		http.Error(w, "can't read encodedClaim", http.StatusBadRequest)
		return
	}

	err = encodedClaim.CreateAndStore()
	if err != nil {
		log.Errorf("error storing encodedClaim: %v", err)
		message := "the claim " + encodedClaim.Id + " already exists"
		if err.Error() == message {
			http.Error(w, message, http.StatusBadRequest)
			return
		}
		http.Error(w, "error storing encodedClaim", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
}

func DeleteClaim(w http.ResponseWriter, r *http.Request) {
	if err := checkAuth(w, r); err != nil {
		return
	}
	vars := mux.Vars(r)
	claimId := vars["claimID"]

	if err := datamodel.DeleteClaim(claimId); err != nil {
		log.Errorf("error deleting %s: %s", claimId, err)
		http.Error(w, "error deleting stored claim", http.StatusBadRequest)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
}

func GetClaimByID(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	claimId := vars["claimID"]

	claim, err := datamodel.GetClaim(claimId)
	if err != nil {
		log.Errorf("error retrieving %s: %s", claimId, err)
		// TODO maybe check different errors
		http.Error(w, "error retrieving claim", http.StatusBadRequest)
		return
	}
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	err = json.NewEncoder(w).Encode(claim)
	if err != nil {
		log.Errorf("error encoding JSON: %v", err)
	}
	return
}

func RequestSigned(w http.ResponseWriter, req *http.Request) {
	//TODO
	vars := mux.Vars(req)
	claimId := vars["claimID"]
	nonce := vars["nonce"]
	log.Debugf("nonce received: %s", nonce)
	claim, err := datamodel.GetEncoded(claimId)

	if err != nil {
		log.Errorf("error retrieving %s: %s", claimId, err)
		// TODO maybe check different errors
		http.Error(w, "error retrieving claim", http.StatusBadRequest)
		return
	}

	// now I have to sign the encodedClaim
	r, s, err := crypto.Sign(nonce)
	if err != nil {
		log.Errorf("error signing %s: %s", claimId, err)
		http.Error(w, "error signing claim", http.StatusInternalServerError)
		return
	}
	derEncoding, err := crypto.EncodeSignatureDER(r, s)
	if err != nil {
		log.Errorf("error encoding signature: &v", err)
		http.Error(w, "internal error during DER encoding", http.StatusInternalServerError)
	}

	claim.Signature = base64.StdEncoding.EncodeToString(derEncoding)
	//claim.Signature = string(derEncoding)map

	// now I have to add my public key
	pubKey, err := crypto.GetPublicKey()
	pubPem := crypto.EncodePublicKeyToPem(pubKey)
	claim.PublicKey = pubPem

	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	w.WriteHeader(http.StatusOK)
	err = json.NewEncoder(w).Encode(claim)
	if err != nil {
		log.Errorf("error encoding JSON: %v", err)
	}
	return
}

func GetClaimList(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")

	claimList, err := datamodel.GetClaimList()

	if err != nil {
		log.Errorf("error reading claim list: %v", err)
		http.Error(w, "can't retrieve claim list", http.StatusInternalServerError)
		return
	}

	w.WriteHeader(http.StatusOK)
	err = json.NewEncoder(w).Encode(claimList)
	if err != nil {
		log.Errorf("error encoding JSON: %v", err)
	}
	return
}
